{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { Fragment, useState, useEffect, useCallback } from 'react';\nimport { ToastContainer } from 'react-toastify';\nimport smoothscroll from 'smoothscroll-polyfill'; // Languages\n\nimport { i18n, appWithTranslation } from '@languages/index';\n// Components\nimport { Header, Footer, Img, Splash } from '@components/index'; // Redux\n\nimport { Provider } from 'react-redux';\nimport withRedux from 'next-redux-wrapper';\nimport reduxStore from '@redux/store';\n/**\n * App layout\n * @author: Giang Nguyen\n */\n\nconst AppLayout = props => {\n  // Constructor\n  const {\n    Component,\n    pageProps,\n    store,\n    router\n  } = props;\n  const {\n    0: state,\n    1: setState\n  } = useState({\n    isShowMenu: router.pathname != '/' ? false : true,\n    isScroll: false,\n    isSticky: false,\n    isShowBackTop: false,\n    pageLoading: true,\n    section: ''\n  });\n  const {\n    isShowMenu,\n    isScroll,\n    isSticky,\n    isShowBackTop,\n    pageLoading,\n    section\n  } = state; // useEffect as componentDidMount\n\n  useEffect(() => {\n    smoothscroll.polyfill();\n    loadPage();\n  }, []); // useEffect as componentDidUpdate for router.pathname\n\n  useEffect(() => {\n    setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n      isShowMenu: router.pathname != '/' ? false : true\n    }));\n  }, [router.pathname]);\n\n  const loadPage = () => {\n    let interval = setInterval(() => {\n      if (!process.server && document.readyState === 'complete') {\n        clearInterval(interval);\n        setTimeout(() => {\n          setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n            pageLoading: false\n          }));\n        }, 800);\n      }\n    }, 100);\n  };\n\n  const handleScroll = useCallback(() => {\n    const body = document.body;\n    let client = document.documentElement;\n    client = client.clientHeight ? client : body; // Handle sticky header\n\n    if (client.scrollTop > 0 && !isSticky) {\n      setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n        isSticky: true\n      }));\n    }\n\n    if (client.scrollTop <= 0 && isSticky) {\n      setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n        isSticky: false\n      }));\n    }\n\n    if (!isScroll) {\n      // Handle active menu item\n      let elements = document.querySelectorAll('div.components__header-menu-item');\n      elements.forEach((elm, index) => {\n        let current_element_id = elm.getAttribute('data-toggle');\n        let current_element = document.getElementById(current_element_id ? current_element_id : '');\n        let next_element_id = elements[index + 1] ? elements[index + 1].getAttribute('data-toggle') : '';\n        let next_element = document.getElementById(next_element_id ? next_element_id : '');\n        let first_element_id = elements[0] ? elements[0].getAttribute('data-toggle') : '';\n        let first_element = document.getElementById(first_element_id ? first_element_id : '');\n\n        if (current_element) {\n          let current_offset_top = current_element.offsetTop - 175;\n\n          if (next_element) {\n            let next_offset_top = next_element.offsetTop - 175;\n\n            if (client.scrollTop >= current_offset_top && client.scrollTop < next_offset_top) {\n              setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n                section: current_element_id ? current_element_id : ''\n              }));\n            }\n          } else {\n            if (client.scrollTop >= current_offset_top) {\n              setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n                section: current_element_id ? current_element_id : ''\n              }));\n            }\n          }\n        }\n\n        if (first_element) {\n          let first_offset_top = first_element.offsetTop - 155;\n\n          if (client.scrollTop < first_offset_top) {\n            setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n              section: ''\n            }));\n          }\n        }\n      });\n    } // Handle show back to top button\n\n\n    if (document.documentElement.scrollTop >= 100 && !isShowBackTop) {\n      setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n        isShowBackTop: true\n      }));\n    }\n\n    if (document.documentElement.scrollTop < 100 && isShowBackTop) {\n      setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n        isShowBackTop: false\n      }));\n    }\n  }, [isScroll, isSticky, isShowBackTop]); // useEffect as componentDidUpdate and componentWillUnmount for handleScroll\n\n  useEffect(() => {\n    window.addEventListener('load', handleScroll);\n    window.addEventListener('scroll', handleScroll);\n    return () => {\n      window.removeEventListener('load', handleScroll);\n      window.removeEventListener('scroll', handleScroll);\n    };\n  }, [handleScroll]);\n\n  const scrollTo = section => {\n    setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n      isScroll: true,\n      section\n    }));\n    setTimeout(() => {\n      setState(prevState => _objectSpread(_objectSpread({}, prevState), {}, {\n        isScroll: false\n      }));\n    }, 1000);\n  };\n\n  const backToTop = () => {\n    window.scrollTo({\n      top: 0,\n      behavior: 'smooth'\n    });\n  };\n\n  return __jsx(\"div\", {\n    className: \"layouts__app\"\n  }, __jsx(Provider, {\n    store: store\n  }, __jsx(ToastContainer, null), __jsx(Header, {\n    router: router,\n    isShowMenu: isShowMenu,\n    isSticky: isSticky,\n    pageLoading: pageLoading,\n    section: section,\n    scrollTo: scrollTo\n  }), !pageLoading ? __jsx(Fragment, null, __jsx(Img, {\n    className: \"layouts__app-bg\",\n    src: \"/image-asset/app-bg.png\"\n  }), __jsx(\"div\", {\n    className: `layouts__app-backtop justify-center items-center ${isShowBackTop ? 'flex' : 'dn'}`,\n    onClick: () => backToTop()\n  }, __jsx(\"i\", {\n    className: \"fa fa-chevron-up\"\n  })), __jsx(\"div\", {\n    className: \"layouts__app-body\",\n    id: \"body-section\"\n  }, __jsx(Component, _extends({}, pageProps, {\n    router: router,\n    locale: i18n.language ? i18n.language : 'en'\n  })))) : __jsx(Splash, null), __jsx(Footer, {\n    router: router,\n    pageLoading: pageLoading\n  })));\n};\n\nAppLayout.getInitialProps = async ({\n  Component,\n  ctx\n}) => {\n  return {\n    pageProps: _objectSpread({}, Component.getInitialProps ? await Component.getInitialProps(ctx) : {})\n  };\n};\n\nexport default withRedux(reduxStore)(appWithTranslation(AppLayout));","map":null,"metadata":{},"sourceType":"module"}